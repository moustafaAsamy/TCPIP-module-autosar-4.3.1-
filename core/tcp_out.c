
#include "lwip/opt.h"
#include "lwip/tcp_impl.h"
#include "lwip/def.h"
#include "lwip/mem.h"
#include "lwip/ip_addr.h"
#include "lwip/netif.h"
#include "lwip/inet_chksum.h"
#include "autosar_includes/TCPIP_config.h"
#include <string.h>

/* Define some copy-macros for checksum-on-copy so that the code looks
   nicer by preventing too many ifdef's. */
#define LWIP_MAX(x , y)  (((x) > (y)) ? (x) : (y))
#define LWIP_MIN(x , y)  (((x) < (y)) ? (x) : (y))

#define TCP_DATA_COPY(dst, src, len, seg)                     MEMCPY(dst, src, len)
#define TCP_DATA_COPY2(dst, src, len)                         MEMCPY(dst, src, len)


/** Define this to 1 for an extra check that the output checksum is valid
 * (usefule when the checksum is generated by the application, not the stack) */
#ifndef TCP_CHECKSUM_ON_COPY_SANITY_CHECK
#define TCP_CHECKSUM_ON_COPY_SANITY_CHECK   0
#endif

/* Forward declarations.*/
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb);

/** Allocate a pbuf and create a tcphdr at p->payload, used for output
 * functions other than the default tcp_output -> tcp_output_segment
 * (e.g. tcp_send_empty_ack, etc.)
 *
 * @param pcb tcp pcb for which to send a packet (used to initialize tcp_hdr)
 * @param optlen length of header-options
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen);
  if (p != NULL) {


    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = (pcb->local_port);
    tcphdr->dest = (pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = (pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = (pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
  }
  return p;
}

/**
 * Called by tcp_close() to send a segment including FIN flag but not data.
 *
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent  ; last_unsent->next != NULL; last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
      pcb->flags |= TF_FIN;
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);//TCP_FIN ==0x01U
}

/**
 * Create a TCP segment with prefilled header.
 *
 * Called by tcp_write and tcp_enqueue_flags.
 *
 * @param pcb Protocol control block for the TCP connection.
 * @param p pbuf that is used to hold the TCP header.
 * @param flags TCP flags for header.
 * @param seqno TCP sequence number of this packet
 * @param optlen
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg * tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optlen)
{
  struct tcp_seg *seg;
  if ((seg = (struct tcp_seg *)mem_malloc(sizeof(struct tcp_seg))) == NULL)
  {
    pbuf_free(p);
    return NULL;
  }
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;     //   (p->tot_len = length of data only without headers || or = 4 if its syn segment  )we don't add the extra word in the seg>len
  if (pbuf_header(p, TCP_HLEN))       /* p->tot_len = p->tot_len +TCP header size  , pay_load points to the header instead of data */
  {
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;      // type casting the payload will lead to take only the header only
  seg->tcphdr->src = pcb->local_port;
  seg->tcphdr->dest = pcb->remote_port;
  seg->tcphdr->seqno = seqno;
  /* ackno  ,wnd and chksum  is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
  seg->tcphdr->urgp = 0;
  return seg;
} 

/** Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
 *
 * @param pcb the tcp pcb to check for
 * @param len length of data to send (checked agains snd_buf)
 * @return ERR_OK if tcp_write is allowed to proceed, another err_t otherwise
 */
static err_t tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD))
  {return ERR_CONN;}
  else if (len == 0)
  {return ERR_OK; }
  if (len > pcb->snd_buf) /* fail on too much data */
  {
    pcb->flags |= MEMERR;
    return ERR_MEM;
  }

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if (pcb->snd_queuelen >= TCP_SND_QUEUELEN)
  {
    pcb->flags |= MEMERR;
    return ERR_MEM;
  }
  return ERR_OK;
}

/**
 * Write data for sending (but does not send it immediately).
 *
 * It waits in the expectation of more data being sent soon (as
 * it can send them more efficiently by combining them together).
 * To prompt the system to send data now, call tcp_output() after
 * calling tcp_write().
 *
 * @param pcb Protocol control block for the TCP connection to enqueue data for.
 * @param arg Pointer to the data to be enqueued for sending.
 * @param len Data length in bytes
 * @param apiflags combination of following flags :
 * - TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */


err_t tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0;         /* position in 'arg' data */
  u16_t queuelen;
  err_t err;
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);   /* don't allocate segments bigger than half the maximum window we ever received */
  err = tcp_write_checks(pcb, len);                           //Checks if tcp_write is allowed or not (checks state, snd_buf and snd_queuelen).
  if (err != ERR_OK)
  { return err;}
  queuelen = pcb->snd_queuelen;
 /*
  * First time after establish will not enter
  * this case is used when your application is in rush   or something immediate has changed
  * so before all the last segment has been sent , your app needed to write again
 */
  if (pcb->unsent != NULL) /* Find the tail of the unsent queue. */
  {for ( last_unsent = pcb->unsent; last_unsent->next != NULL;last_unsent = last_unsent->next);}     // loop till  you find the last element in the the unsent queue
  /* data segmention
   *  Create new segments.
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len)
  {                                                                       // len is the length of data to be send
    struct pbuf *p=0;                                                       // new pointer to buffer
    u16_t left = len - pos;                                               // pos a position inside the data length , left data to be segmented in the next segment
    u16_t max_len = mss_local ;                                           // updated by the window size
    u16_t seglen = left > max_len ? max_len : left;                       // seglen is the segment length which is the min(left and max_len)
    if (apiflags & TCP_WRITE_FLAG_COPY)                                   // normal case
    {
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen ) )== NULL)              // Length of data only and payload point to the start of data
      {goto memerr;}


      //TCP_DATA_COPY2(  (char *) p->payload , (u8_t*)arg + pos, seglen);
      memcpy(p->payload,(u8_t*)arg + pos,seglen);
    }
    queuelen = queuelen + 1;
    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if (queuelen > TCP_SND_QUEUELEN)
    {
      pbuf_free(p);
      goto memerr;
    }
    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, 0)) == NULL)         //the sequence number increment each time by the length of the segment
    {goto memerr; }
    /* first segment of to-be-queued data? */
    if (queue == NULL)
    { queue = seg;}
    else
    { prev_seg->next = seg;}                                                          /* Attach the segment to the end of the queued segments */
    prev_seg = seg;                                                                   /* remember last segment of to-be-queued data for next iteration */
    pos += seglen;                                                                    /* update the pos in the data , from which we start to copy data in the next segment */
  }


  if (last_unsent == NULL)
  {pcb->unsent = queue;}
  else
  {last_unsent->next = queue; }
  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;                                                                   // next sequence to be buffered
  pcb->snd_buf -= len;                                                                   // remove from the available buffer the total data length
  pcb->snd_queuelen = queuelen;
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0))          /* Set the PSH flag in the last segment that we enqueued. */
  {TCPH_SET_FLAG(seg->tcphdr, TCP_PSH); }
  return ERR_OK;
memerr:
  pcb->flags |= MEMERR;
  if (concat_p != NULL) {
    pbuf_free(concat_p);
  }
  if (queue != NULL) {
    tcp_segs_free(queue);
  }
  return ERR_MEM;
}


/**
 * Enqueue TCP options for transmission.
 *
 * Called by tcp_connect(), tcp_listen_input(), and tcp_send_ctrl().
 *
 * @param pcb Protocol control block for the TCP connection.
 * @param flags TCP header flags to set in the outgoing segment.
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  if (pcb->snd_queuelen >= TCP_SND_QUEUELEN)             /* check for configured max queuelen  which is 4 */
  {
    pcb->flags |= MEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_buf == 0)
  { return ERR_MEM; }
  /* Allocate pbuf with room for TCP header
   * optlen == 4  one word it will be added in the buffer length only but in the seg>len will not be registered
   */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, 0)) == NULL)
  {
    pcb->flags |= MEMERR;
    return ERR_MEM;
  }
  /* Allocate memory for tcp_seg, and fill in fields. */
  if (     (seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, 0)  ) == NULL)
  {
    pcb->flags |= MEMERR;
    return ERR_MEM;
  }
  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL)
  { pcb->unsent = seg; }                                  // First element
  else
  {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
    useg->next = seg;
  }
  /* SYN and FIN increment the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN))
  {
    pcb->snd_lbb++;                                      // next byte to be buffered
    pcb->snd_buf--;                                      // remove only one byte
  }
  if (flags & TCP_FIN)
  {pcb->flags |= TF_FIN;}
  pcb->snd_queuelen = pcb->snd_queuelen + 1;             /* update number of segments on the queues */
  return ERR_OK;
}



/** Send an ACK without data.
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  u8_t optlen = 0;



  p = tcp_output_alloc_header(pcb, optlen, 0, (pcb->snd_nxt));   ///////////////mohmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
  if (p == NULL) {

    return ERR_BUF;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);

  /* NB. MSS option is only sent on SYNs, so ignore it here */


#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
        IP_PROTO_TCP, p->tot_len);
#endif


  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);

  pbuf_free(p);

  return ERR_OK;
}

/**
 * Find out what we can send and send it  tcp_input
 *
 * @param pcb Protocol control block for the TCP connection to send data
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg, *useg;
  u32_t wnd, snd_nxt;
  if (tcp_input_pcb == pcb)  /* First, check if we are invoked by the TCP input processing code. If so, we do not output anything.*/
  {return ERR_OK;}
  wnd = pcb->snd_wnd ;
  seg = pcb->unsent;
  /* If the TF_ACK_NOW flag is set and no data will be sent (either
   * because the ->unsent queue is empty or because the window doesnot allow it).
   * usually used  in ackking data
   * construct an empty ACK segment and send it.
   */

  if (pcb->flags & TF_ACK_NOW &&   (seg == NULL || (seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd))
  {return tcp_send_empty_ack(pcb);}

  useg = pcb->unacked; /* useg should point to last segment on unacked queue */
  if (useg != NULL)
  {for (; useg->next != NULL; useg = useg->next);}

  /* data available and window allows it to be sent?
   * loop on the pcb->unsent list to send the segment
   * Condition is that sequence number ++ length is within the window
   */
 u8_t o= (seg->tcphdr->seqno) -(pcb->lastack +seg->len);// ( (seg->tcphdr->seqno) -(pcb->lastack +seg->len)) <= wnd;
  //while ( (seg != NULL) &&   (((seg->tcphdr->seqno) -(pcb->lastack +seg->len)) <= wnd) )
  while (  seg != NULL &&                ((seg->tcphdr->seqno) -     pcb->lastack +    seg->len )<= wnd   )
 {
    pcb->unsent = seg->next;
    if (pcb->state != SYN_SENT)
     {
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~TF_ACK_NOW;
    }
    tcp_output_segment(seg, pcb);
    snd_nxt = (seg->tcphdr->seqno) + TCP_TCPLEN(seg);    //  send_next = sequence number + (segment->len  "which could be zero) + (one if its syn or fin segment )
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt))
    {pcb->snd_nxt = snd_nxt;}

    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0)
    {
      seg->next = NULL;
      if (pcb->unacked == NULL) /* unacked list is empty? */
      {
        pcb->unacked = seg;
        useg = seg;
      }
      else /* unacked list is not empty? */
      {
          /* add segment to tail of unacked list */
          useg->next = seg;
          useg = useg->next;
      }
    }
    else /* do not queue empty segments on the unacked list */
    {tcp_seg_free(seg);}
    seg = pcb->unsent;
  }
  pcb->flags &= ~MEMERR ;
  return ERR_OK;
}

/**
 * Called by tcp_output() to actually send a TCP segment over IP.
 *
 * @param seg the tcp_seg to send
 * @param pcb the tcp_pcb for the TCP connection used to send the segment
 */
static void tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb)
{
  /* The TCP header has already been constructed, but the ackno and wnd fields remain. */
  seg->tcphdr->ackno = (pcb->rcv_nxt);
  seg->tcphdr->wnd = (pcb->rcv_ann_wnd);     /* advertise our receive window size in this TCP segment */
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
  /* Set retransmission timer running if it is not currently enabled This must be set before checking the route. */
  if (pcb->rtime == -1)
    {pcb->rtime = 0;}
  if (pcb->rttest == 0)
  {
    pcb->rttest = tcp_ticks;
    pcb->rtseq = (seg->tcphdr->seqno);
  }
  seg->p->payload = seg->tcphdr;
  seg->tcphdr->chksum = 0;
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),&(pcb->remote_ip),IP_PROTO_TCP, seg->p->tot_len);
  ip_output_autosar(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,IP_PROTO_TCP,sockets_list[pcb->socket_ID].TcpIpAddrId);
}

/**
 * Send a TCP RESET packet (empty segment with RST flag set) either to
 * abort a connection or to show that there is no matching local connection
 * for a received segment.
 *
 * Called by tcp_abort() (to abort a local connection), tcp_input() (if no
 * matching local pcb was found), tcp_listen_input() (if incoming segment
 * has ACK flag set) and tcp_process() (received segment in the wrong state)
 *
 * Since a RST segment is in most cases not sent for an active connection,
 * tcp_rst() has a number of arguments that are taken from a tcp_pcb for
 * most other segment output functions.
 *
 * @param seqno the sequence number to use for the outgoing segment
 * @param ackno the acknowledge number to use for the outgoing segment
 * @param local_ip the local IP address to send the segment from
 * @param remote_ip the remote IP address to send the segment to
 * @param local_port the local TCP port to send the segment from
 * @param remote_port the remote TCP port to send the segment to
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN);
  if (p == NULL) {

      return;
  }


  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = (local_port);
  tcphdr->dest = (remote_port);
  tcphdr->seqno = (seqno);
  tcphdr->ackno = (ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  tcphdr->wnd =  (TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
#endif

    /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);

}


/**
 * Requeue all unacked segments for retransmission
 *
 * Called by tcp_slowtmr() for slow retransmission.
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
  sockets_list[pcb->socket_ID].data_flag =1;
}





/**
 * Send keepalive packets to keep a connection active although
 * no data is sent over it.
 *
 * Called by tcp_slowtmr()
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  struct pbuf *p;
  struct tcp_hdr *tcphdr;




   
  p = tcp_output_alloc_header(pcb, 0, 0, (pcb->snd_nxt - 1));
  if(p == NULL) {

    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
#endif


  /* Send output to IP */

  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);


  pbuf_free(p);

}




